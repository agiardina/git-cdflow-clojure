(ns cdflow.git
  (:require [clojure.java.io :as io]
            [clojure.string :as str]
            [clj-jgit.porcelain :as git]
            [clj-jgit.internal :as git-internal]
            [clojure.pprint])
  (:import [java.lang String]
           [java.nio.charset StandardCharsets]
           [org.eclipse.jgit.lib ObjectInserter CommitBuilder PersonIdent]
           [org.eclipse.jgit.transport RefSpec]
           [org.eclipse.jgit.revwalk.filter RevFilter]
           [org.eclipse.jgit.revwalk RevWalk RevCommit]
           [org.eclipse.jgit.notes NoteMap NoteMapMerger]))

;@fixme is the right place where to put this code? Is the code that we want?
(System/setProperty "jsse.enableSNIExtension" "false")

(defn get-branch-name-from-ref [ref]
  (str/replace-first (.getName ref) "refs/heads/" ""))

(defn branch-list
  ([repo-path opt]
    (git/with-repo repo-path
      (->> (git/git-branch-list repo opt)
           (map get-branch-name-from-ref))))
  ([repo-path]
    (branch-list repo-path :local)))

;@todo it seems the cli-jigt has this functioanlity, consider refactoring
(defn branch-list-contains
  "Get a list of branches in the Git repo. Return the default objects generated by the JGit API."
  ([repo-path commit]
   (branch-list-contains repo-path commit  :all))
  ([repo-path commit opt]
   (git/with-repo repo-path
      (let [opt-val {:all org.eclipse.jgit.api.ListBranchCommand$ListMode/ALL
                  :remote org.eclipse.jgit.api.ListBranchCommand$ListMode/REMOTE}
         branches (if (= opt :local)
                    (-> repo
                        (.branchList)
                        (.setContains commit)
                        (.call))
                    (-> repo
                        (.branchList)
                        (.setContains commit)
                        (.setListMode (opt opt-val))
                        (.call)))]
        (->> (seq branches)
             (map get-branch-name-from-ref))))))

(defn ->branch
  [id kids]
  (conj kids id))

(defn ->leaf
  [id]
  (list id))

(defn descendant
  [adj-list node]
  (seq (map second (filter #(= (first %) node) adj-list))))

(defn ->tree
  [adj-list node]
  (let [->tree' (partial ->tree adj-list)]
    (if-let [kid-ids (descendant adj-list node)]
      (->branch node (map ->tree' kid-ids))
      (->leaf node))))

(defn ->adj [vec adj]
  (if (= 2 (count vec))
    (conj adj (lazy-seq vec))
    (->adj (next vec) (conj adj (take 2 vec)))))

(defn branch-tree [repo opt]
  (let [branches     (map #(str "root/" %) (branch-list repo opt))
        vec-branches (map #(str/split % #"/") branches)
        adj-branches (map #(->adj % []) vec-branches)
        adj-list     (distinct (apply concat adj-branches))]
    (->tree adj-list "root")))

(defn create-menu [item]
  (if (seq? item)
    (map create-menu item)
    "a"))

(defn- parse-note-string [note]
  (->>  (str/split note #" -> ")
        (map #(str/replace % #"\[|\]" ""))))

(defn- get-parent-from-note [note] (first (parse-note-string note)))

(defn- get-child-from-note [note] (last (parse-note-string note)))

(defn- flat-parents-children [flat-coll]
  (let [flat-parents (->> flat-coll
                          (map #(get-parent-from-note %))
                          (set)
                          (into [])
                          (reduce (fn [res elem] (assoc res (keyword elem) {})) {}))]
    (reduce (fn [res elem]
             (assoc  res
                     (keyword (get-parent-from-note elem))
                     (assoc  (get res (keyword (get-parent-from-note elem)))
                             (keyword (get-child-from-note elem))
                             {}))) flat-parents flat-coll)))

(defn- nest-parents-children
  ([result coll branch]
   (let [new-result (assoc result branch (get coll branch))]
     (->> (map #(nest-parents-children (get-in new-result [branch (key %)]) coll (key %)) (get new-result branch))
          (assoc new-result branch))))
  ([result coll] (nest-parents-children result coll :master)))

(defn- format-parents-children [result tree]
  (reduce-kv (fn [res k v]
    (if (= 0 (count v))
      (assoc res :name (subs (str k) 1) :size 1000)
      (assoc res :name (subs (str k) 1) :children (map #(format-parents-children res %) v)))) result tree))

(defn- get-tree-root [flat-tree]
  (try
    (->> flat-tree
      (reduce-kv (fn [r k v] (assoc r k (reduce-kv (fn [rr kk vv] (if (not (nil? (get vv k))) (+ rr 1) rr)) 0 flat-tree))) {})
      (filter #(= 0 (second %)))
      (first)
      (first))
    (catch Exception e nil)))

(defn- get-commit-id [repo ref]
  (-> repo
      .getRepository
      (.resolve ref)))

(defn get-head-commit-object [repo]
  (let [repository (-> repo .getRepository)
        head-id (-> repository (.resolve "HEAD"))]
    (-> (RevWalk. repository) (.parseCommit head-id))))

(defn- get-git-directory-path [repo]
  (-> repo
      .getRepository
      .getDirectory
      .getAbsolutePath))

(defn- sort-versions-list [v-list]
  (->>  v-list
        (map #(str/replace % #"v" ""))
        (sort #(let [split1 (map (fn [x] (Integer. x)) (str/split %1 #"\."))
                     split2 (map (fn [x] (Integer. x)) (str/split %2 #"\."))]
          (if (= 0 (compare (first split1) (first split2)))
            (if (= 0 (compare (second split1) (second split2)))
              (compare (last split1) (last split2))
              (compare (second split1) (second split2)))
            (compare (first split1) (first split2)))))
        (map #(str "v" %))))

(defn- release-name [name]
  (let [sname (-> (str name) (str/split #"\/") last)
        vname (if (re-matches #"^[v|V].*" sname) (str/lower-case (str sname)) (str "v" sname))]
    (cond
      (re-matches #"^v[0-9]{1,3}$" vname) (str "release/" vname ".0.0")
      (re-matches #"^v[0-9]{1,2}\.[0-9]{1,2}$" vname) (str "release/" vname ".0")
      (re-matches #"^v[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}$" vname) (str "release/" vname)
      :else (throw (Exception. "Not a valid release version!")))))

(defn- feature-name [name]
  (as-> name $
        (str $)
        (str/split $ #"\/")
        (last $)
        (str "feature/" $)))

(defn- branch-exists?
  ([repo-path branch]
    (branch-exists? repo-path branch :all))
  ([repo-path branch location]
    (->>  (branch-list repo-path location)
          (map #(str/replace % #"refs\/remotes\/origin\/" ""))
          (filter #(= % branch))
          (count)
          (< 0))))

(defn- git-notes-add! [repo message ref commit]
  (-> repo
    .notesAdd
    (.setMessage message)
    (.setNotesRef (str "refs/notes/" ref))
    (.setObjectId commit)
    .call))

(defn- git-push-notes! [repo ref]
  (-> repo
    .push
    (.add (str "refs/notes/" ref))
    (.setRemote "origin")
    .call))

(defn- git-push! [repo]
  (-> repo
    .push
    (.setRemote "origin")
    .call))

(defn git-checkout-branch! [repo-path branch]
  (git/with-repo repo-path
    (if (branch-exists? repo-path branch :local)
      (git/git-checkout repo branch)
      (git/git-checkout repo branch true))))

(defn get-all-commits [repo-path]
  (git/with-repo repo-path
    (->> repo
      git/git-log
      (map (fn [x] {:commit (.getName x)
                    :message (.getFullMessage x)
                    :time (.getCommitTime x)
                    :author {:name (.getName (.getAuthorIdent x))
                             :email (.getEmailAddress (.getAuthorIdent x))}})))))

(defn get-all-ref-commits [repo-path]
  (git/with-repo repo-path (->> repo git/git-log)))

(defn parse-git-notes [repo-path]
  (try
    (git/with-repo repo-path
      (let [repository (.getRepository repo)]
        (->>  (.call (.setNotesRef (.notesList repo) "refs/notes/cdflow"))
              (map #(String. (.getBytes (.open repository (.getData %))) (StandardCharsets/UTF_8)))
              (map #(clojure.string/split % #"\n"))
              (flatten)
              (filter #(re-matches #"\[(.*)->(.*)\]" %)))))
    (catch Exception e [])))

(defn notes->tree [repo-path]
  (try
    (git/with-repo repo-path
      (let [flat-structure (->> repo-path
                                (parse-git-notes)
                                (flat-parents-children))
            tree-root (get-tree-root flat-structure)]
            (as-> (assoc {} tree-root {}) $
                  (nest-parents-children $ flat-structure tree-root)
                  (format-parents-children {} $))))
    (catch Exception e {})))

(defn add-el [node] (if (map? node) (assoc node :test "me") node))

(defn git-fetch-with-notes!
  ([repo-path remote]
    (git/with-repo repo-path
      (let [git-dir (get-git-directory-path repo)
            current-branch (git/git-branch-current repo)]
        (git/git-fetch-all repo remote)
        (if (not (.isFile (io/file (str git-dir "/refs/notes/cdflow"))))
          (git/git-fetch repo remote "refs/notes/cdflow:refs/notes/cdflow"))
        (git/git-checkout repo "refs/notes/cdflow")
        (git/git-fetch repo remote "refs/notes/cdflow:refs/notes/origin/cdflow")
        (git/git-merge repo (get-commit-id repo "refs/notes/origin/cdflow") :theirs)
        (git/git-checkout repo current-branch))))
  ([repo-path]
    (git-fetch-with-notes! repo-path "origin")))

(defn git-fetch! [repo-path]
    (git/with-repo repo-path
        (git/git-fetch repo)))

(defn git-fetch-notes!
  ([repo-path]
   (git-fetch-notes! repo-path "origin"))
  ([repo-path remote]
    (git/with-repo repo-path (git/git-fetch repo remote "refs/notes/cdflow:refs/notes/origin/cdflow"))))

(defn- update-ref! [repo refs object-id]
  (let [local-ref-update (.updateRef  (.getRepository repo) "refs/notes/cdflow")]
    (.setNewObjectId local-ref-update object-id)
    (.disableRefLog local-ref-update)
    (.forceUpdate local-ref-update)))=

(defn get-merge-base [repo-path commit-a commit-b]
  (git/with-repo repo-path
                 (let [walk (git-internal/new-rev-walk repo)
                       rev-a (.lookupCommit walk (git-internal/resolve-object commit-a repo))
                       rev-b (.lookupCommit walk (git-internal/resolve-object commit-b repo))]
                   (doto walk
                         (.setRevFilter RevFilter/MERGE_BASE)
                         (.markStart rev-a)
                         (.markStart rev-b))
                   (.next walk))))

;@todo refactor this method
;@todo get the right person from the git config
(defn git-merge-notes!
  ([repo-path remote]
    (git/with-repo repo-path
    (let [repository (.getRepository repo)
          notes-local-repo (.getRef repository "refs/notes/cdflow")
          notes-origin-repo (.getRef repository "refs/notes/origin/cdflow")]

      (cond
        (and (not notes-local-repo) (not notes-origin-repo)) ;Nothing to do, there are not merge local notes or remote notes
          true
        (not notes-local-repo)
          (update-ref! repo "refs/notes/cdflow" (.getObjectId notes-origin-repo)) ;First merge, notes only on remote
        (not notes-origin-repo)
          true
          :else
          (let [walk (git-internal/new-rev-walk repo)
                reader (.newObjectReader repository)
                inserter (.newObjectInserter repository)
                merger (NoteMapMerger. repository)
                empty (NoteMap/newEmptyMap)
                person (PersonIdent. "me", "me@example.com")
                commit-builder (CommitBuilder.)
                commit-local (.parseCommit walk (.getObjectId notes-local-repo))
                commit-origin (.parseCommit walk (.getObjectId notes-origin-repo))
                ours (NoteMap/read reader commit-local)
                theirs (NoteMap/read reader commit-origin)
                base (get-merge-base repo-path commit-local commit-origin)
                base-note (if base (NoteMap/read reader base) empty)
                result (.merge merger base-note ours theirs)]

            (cond
              (= commit-origin base) ;Already merged
                true
              (= commit-local base) ;Fast forward
                (update-ref! repo "refs/notes/cdflow" (.getObjectId notes-origin-repo))
              :else
                (do
                  (doto commit-builder
                    (.setTreeId (.writeTree result inserter))
                    (.setCommitter person)
                    (.setAuthor person)
                    (.setMessage "CDFlow Merge Notes")
                    (.setParentIds commit-local commit-origin))

                    (update-ref! repo "refs/notes/cdflow" (.insert inserter commit-builder))))

                (.flush inserter)
                true
                )))))

  ([repo-path]
   (git-merge-notes! repo-path "origin")))

(defn git-fetch-and-merge-notes! [repo-path]
  (git-fetch! repo-path)
  (git-fetch-notes! repo-path)
  (git-merge-notes! repo-path))

(defn get-parent "Return the parent of the current branch" [repo-path]
  (git/with-repo repo-path
    (let [current-branch (git/git-branch-current repo)]
      (->> (parse-git-notes repo-path)
            (map #(str/split % #"->"))
            (map #(map (fn [x] (str/replace (str/trim x) #"\[|\]" "")) %))
            (filter #(str/includes? (second %) current-branch))
            (first)
            (first)))))

(defn parent-pull! [repo-path]
  (git/with-repo repo-path
    (if (git-fetch-and-merge-notes! repo-path)
      (let [parent (get-parent repo-path)
            parent-commit-id (get-commit-id repo (str "refs/remotes/origin/" parent))]
            (git/git-merge repo parent-commit-id)))))

(defn parent-set! [repo-path branch]
  (if (branch-exists? repo-path branch)
    (git/with-repo repo-path
      (let [current-branch (git/git-branch-current repo)]
        (as-> (parse-git-notes repo-path) $
          (map #(str/split % #"->") $)
          (map #(map (fn [x] (str/replace (str/trim x) #"\[|\]" "")) %) $)
          (filter #(not (str/includes? (second %) current-branch)) $)
          (concat $ [[branch current-branch]])
          (map #(str/join " -> " %) $)
          (map #(str "[" % "]") $)
          (str/join "\n" $)
          (git-notes-add! repo $ "cdflow" (get-head-commit-object repo)))))
    (throw (Exception. (str "Branch " branch " doesn't exist!")))))

(defn get-releases-list [repo-path]
  (git/with-repo repo-path
    (->>  (branch-list repo-path :all)
          (filter #(re-matches #"(.*)release\/v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" %))
          (map #(str/replace % #"release\/" ""))
          (map #(str/replace % #"refs\/remotes\/origin\/" ""))
          set
          (into [])
          sort-versions-list)))

(defn release-checkout! [repo-path version]
  (git/with-repo repo-path
    (->> version
         release-name
         (git-checkout-branch! repo-path))))

(defn release-start! [repo-path from to]
  (let [source (release-name from)
        target (release-name to)]
    (if (and (branch-exists? repo-path source) (git-fetch-and-merge-notes! repo-path))
      (git/with-repo repo-path
        (git-checkout-branch! repo-path source)
        (git/git-pull repo)
        (if (not (branch-exists? repo-path target)) (git/git-branch-create repo target))
        (git-checkout-branch! repo-path target)
        (parent-set! repo-path source)
        (git-push-notes! repo "cdflow")
        (git-push! repo))
      (throw (Exception. (str "Branch " source " doesn't exist!"))))))

(defn feature-checkout! [repo-path name]
  (git/with-repo repo-path
    (->> name
         feature-name
         (git-checkout-branch! repo-path))))

(defn feature-start! [repo-path name]
  (git/with-repo repo-path
    (let [parent (git/git-branch-current repo)
          feature (feature-name name)]
      (git/git-branch-create repo feature)
      (git-checkout-branch! repo-path feature)
      (parent-set! repo-path parent))))

(defn feature-finish! [repo-path]
  (git/with-repo repo-path
    (let [current-branch (git/git-branch-current repo)]
      (if (re-matches #"^feature\/(.*)" current-branch)
        (let [last-feature-commit (get-commit-id repo (str "refs/heads/" current-branch))
              parent (get-parent repo-path)]
          (git-checkout-branch! repo-path parent)
          (git/git-pull repo)
          (git/git-merge repo last-feature-commit)
          (git/git-branch-delete repo [current-branch]))
        (throw (Exception. (str "You are not in a feature branch: " current-branch)))))))